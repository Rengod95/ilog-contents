---
title : Network Layer - DHCP, NAT, Port Forwarding, IPv6, Tunneling
date: 2023/06/08
author: '이인'
tags: ['Network Layer', 'DHCP', 'NAT', 'Port Forwarding', 'IPv6', 'Tunneling']
---

![](https://i.imgur.com/8DvdDW8.png)

IPv4 기준으로 할당가능한 주소가 매우 부족하기 때문에 해당 문제를 해결하기 위해서 DHCP, NAT, IPv6 등의 방법이 존재한다.

# DHCP -Dynamic Host Configuration Protocol
DHCP는 "Plug And Play"를 가능하게 하는 기술입니다. 즉, 사용자는 장치를 네트워크에 연결하기만 하면, DHCP가 나머지 일을 처리해줍니다.

DHCP의 목표 : 네트워크에 조인한 호스트가 네트워크 서버로부터 동적으로 IP 주소를 할당받을 수 있게 하는 것이다.

DHCP는 크게 4단계의 과정으로 클라이언트(네트워크에 조인한 새로운 호스트)에게 아이피를 할당한다.

1. DHCP Discover : 네트워크에 새로 연결된 호스트(클라이언트)는 "DHCP Discover" 메세지를 해당 네트워크 내의 모든 장치에 BroadCast 한다. 선택적 단계이다.
2. DHCP Offer : 해당 네트워크의 DHCP Server가 "DHCP Offer" 메세지와 함께 사용가능한 IP를 포함한 메세지를 BroadCast 한다. 선택적 단계이다.
3. DHCP Request : 클라이언트는 DHCP 서버에 "DHCP Request"메세지를 전송하여 IP주소를 요청한다
4. DHCP Ack : DHCP 서버는 DHCP Request에 대해 DHCP Ack 메세지와 함께 요청받은 IP 주소를 장치에 할당한다.

![](https://i.imgur.com/3LUk5WY.png)


DHCP 는 실제로 IP 주소를 할당하는 것 이외에도 first hop router의 주소, DNS Server의 이름과 주소, 네트워크 마스크(서브넷 마스크) 에 대한 정보를 제공하기도 한다.

## DHCP 예시

예를 들어 노트북을 A 네트워크에 연결하려고 하는 상황에서, 노트북은 A 네트워크에서 정상적인 호스트로 기능하기 위해 DNS 서버의 이름과 주소, first hop router의 주소, 그리고 자신의 동적 IP 주소를 필요로 한다.

이 때 노트북은 DHCP을 통해 DHCP Request를 생성하고 앞선 4단계의 과정이 이루어지며, DHCP ACK가 전달되는 시점에 DHCP 서버는 first hop router 주소와 DNS 서버의 이름과 주소, 클라이언트의 IP 주소에 대한 정보를 함께 제공하게 된다.

결과적으로 이런 모든 과정은 DHCP를 통해 Plug And Play 방식으로 자동으로 이루어지게 된다.

![](https://i.imgur.com/TppyHdI.png)

해당 와이어 샤크 패킷 분석에서, 4개의 연속된 DHCP 프로토콜 패킷에 대해 동일한 Transaction ID 이므로 DHCP 프로토콜의 전과정을 나타내는 패킷들이라는 것을 알 수 있다.

Client 주소가 아직 할당되지 않았으므로 0.0.0.0 으로 표기되며 MAC 주소는 정상적으로 표기됨을 알 수 있다.

Offer 메세지의 Your IP Adress 필드를 통해 해당 클라이언트가 할당받을 IP 주소를 알 수 있다. 그리고 DHCP Server Identifier 필드를 통해 destination IP가 255.255.255.255로 표기되는 것(Discover와 Offer는 브로드캐스팅)과 달리 해당 네트워크의 실제 DHCP 서버의 주소를 알 수 있다.

![](https://i.imgur.com/ocfRwc7.png)

DHCP Request 메세지의 Requested IP Address를 통해 브로드캐스팅임에도 이전에 Offer 메세지를 전달받았던 클라이언트가 전송한 Request 라는 것을 알 수 있다.

DHCP Server Identifier는 Offer 메세지에서 제공받은 것과 동일함을 알 수 있다.

DHCP  ACK 메세지의 Subnet Mask를 보면 255.255.248.0 임을 알 수 있다. 이를 통해 할당 가능한 호스트 주소의 수를 구해보자.

IP 주소를 구성하는 각 세그먼트가 나타낼 수 있는 수의 범위는 0~255 이다. 248을 나타내는 비트영역은 255-248 = 7 즉 7개의 경우의수를 표현가능한 비트가 남아있다는 것이다. 7 = 2^0 + 2^1 + 2^2 이기 때문에 해당 서브넷 마스크를 이진수로 표현해보면

11111111 11111111 11111000 00000000 임을 알 수 있다. 즉 서브넷 마스크를 통해 호스트 ID 로 할당 가능한 비트 수는 총 11비트이다. 이를 CIDR 로 나타내면

client IP Address : 192.168.195.43/21 이다.

## 계층적 주소 지정

개별 네트워크는 IP 주소의 서브넷 파트 부분의 주소를 얻기 위해 ISP 의 주소 공간의 일부분을 할당받는다.

예를 들어 ISP 블럭이 가지고 있는 주소 공간을

200.23.16.0/20 
11001000 00010111 0001xxxx xxxxxxxx

이라고 한다면 해당 ISP 블럭이 표현할 수 있는 주소 범위의 일부분을 각 네트워크 조직에 할당해줄 수 있다.

Organ 0 : 200.23.16.0/23
11001000 00010111 0001000x xxxxxxxx
Organ 1 : 200.23.18.0/23
11001000 00010111 0001001x xxxxxxxx
Organ 2 : 200.23.20.0/23
11001000 00010111 0001010x xxxxxxxx

이렇게 개별 네트워크에 대해 ISP Block 이 가진 IP주소 범위를 계층적으로 할당해 준다면 라우팅 정보를 더욱 효율적으로 관리할 수 있다.
![](https://i.imgur.com/sm7T1CB.png)

인터넷에서 Fly By Night ISP 내의 Organization 0~ 7 에 해당하는 주소로 패킷을 전송한다고 할 때, ISP는 200.23.16.0/20"이라는 하나의 네트워크 주소를 사용해서 모든 조직에 대한 라우팅 정보를 표현할 수 있다.

또한 라우팅 시 더 구체적인 라우팅 정보를 우선적으로 검사한다.

예를 들어 다음과 같은 라우팅 테이블 항목들이 존재할 때,
![](https://i.imgur.com/4QPBS8Y.png)

200.23.16.0 과 200.23.18.0 을 이진수로 나타내보면

200.23.16.0/20
11001000 00010111 0001xxxx xxxxxxxx
200.23.18.0/23
11001000 00010111 0001001x xxxxxxxx

와 같다.

이 때 11001000 00010111 0001001x xxxxxxxx 에 대한 패킷이 수신된다면 해당 패킷은 더욱 구체적인 라우팅 정보를 나타내는 200.23.18.0/23 항목과 연결되어 2번 인터페이스로 전송된다.

그렇다면 ISP는 주소 블럭들을 어떻게 얻을 수 있을까? 바로 ICANN 기관이 주소들을 할당하고 DNS를 관리하며 도메인 정보를 관리하게 된다.

# NAT - Network Address Translation

NAT는 사설 네트워크가 외부 인터넷과 통신할 때 주소를 변환하는 기술이다. 사설 네트워크에서 외부라 나가는 모든 데이터그램은 동일한 단일 IP 주소를 가지게 된다.

NAT의 목적(동기) : 
1. 로컬 네트워크를 구성하는 각 장치의 주소를 변경하지 않고 ISP를 변경할 수 있으며 반대로 외부와 종속되지 않고 로컬 네트워크 내의 장치들의 주소를 변경할 수 있다. 
2. 모든 데이터그램은 단일 IP 주소를 가지게 되기 때문에 외부에서 각 장치에 해당하는 직접적인 주소를 알 수 없어 보안적으로 이점을 가진다. 
3. ISP는 지역 네트워크에 대해 주소 범위를 할당하는 것이 아닌 단일 주소만을 할당해도 된다. 즉 로컬 네트워크를 구성하는 모든 장치에 대해 오직 하나의 IP 주소만 필요로 한다.

NAT 기술은 NAT 라우터를 통해 구현되는데, 해당 NAT 라우터는 다음과 같은 서비스를 제공해야 한다.

1. LAN에서 WAN으로 나가는 모든 Outgoin datagrams에 대해 Source IP 주소와 포트번호를 NAT IP 주소와 새로운 포트 번호로 대체하여 전송한다.
2. Outgoing datagrams의 주소를 변환할 때 사용한 Source IP 주소와 포트번호 - NAT IP 주소와 새로운 포트 번호 쌍에 대한 데이터를 기억하고 있어야 한다.
3. WAN 에서 LAN으로 들어오는 모든 Incoming Datagrams에 대해 NAT IP 주소와 포트번호를 Source IP 주소와 포트번호 쌍으로 변경해야 한다.

NAT 라우터는 주소와 포트 쌍의 정보를 기억하기 위해 NAT Translation Table을 가진다.

![](https://i.imgur.com/taNuKr4.png)

NAT 는 16비트 포트번호 필드를 사용하기에 단일 LAN 주소에 대해 대략 60000개의 동시연결이 가능하다.

NAT는 나가는 요청의 소스 주소를 NAT 장치의 주소로 변경하고 응답을 원래의 장치로 중계하지만, 나가는 요청 없이 외부에서 들어오는 패킷에 대해 어떤 내부 호스트로 라우팅하는 지에 대한 정보를 가지고 있지 않기 때문에 서버 호스팅에 부적합하며  End to End 원칙을 위배한다.

그러나 서버 호스팅 처럼특정 연결에 대한 정보를 항상 유지해야 하는 경우가 있다. 이런 경우에는 포트포워딩을 통해 해당 문제를 해결한다. 

원칙적으로 라우터는 네트워크 계층의 역할까지만 처리해야 하는데 NAT 기술은 IP 주소와 더불어 Port Number 까지 관여하기에 해당 원칙을 위배한다. IPv4 의 주소 부족 문제는 IPv6로 해결해야 하지 NAT를 통해 해결해선 안된다는 논의가 존재한다.

## Port Forwarding

포트포워딩은 공인 IP 주소(LAN을 나타내는 단일 IP 주소)의 특정 포트로 들어오는 모든 패킷을 LAN 내의 특정 IP와 포트로 항상 전달하도록 설정하는 것이다. 이를 통해 외부에서 사설 네트워크 내부의 특정 서버로 지속적인 접근을 가능하게 한다.

# IPv6

주요 동기 : IPv4 의 32비트 주소 공간은 빠른 시일 내에 완전히 할당될 것이라 예측 했기에, 할당 가능한 IP 주소를 늘리기 위해 IPv6 프로토콜이 개발되었다. 추가적으로 헤더 형식이 처리/전달 속도를 높이는 데 도움이 되도록 변경되었다.

IPv6 데이터그램은 고정 길이의 40바이트 헤더를 가지며
IPv4와 달리 분할이 허용되지 않는다.

![](https://i.imgur.com/kT6LDss.png)

- 버전(Version): IP 프로토콜의 버전을 나타내며, IPv6에서는 이 필드의 값이 항상 6입니다.
- 우선순위(Priority): 이 필드는 데이터그램이 처리되는 우선 순위를 나타냅니다. 이는 IPv4의 Type of Service(TOS) 필드에 대응합니다.
- 흐름 라벨(Flow Label): 이 필드는 동일한 데이터그램 플로우에 속하는 각 데이터그램을 식별하는데 사용됩니다. 이는 IPv4에는 없는 필드입니다.
- 페이로드 길이(Payload Length): 이 필드는 IPv6 헤더 이후의 데이터(페이로드)의 길이를 바이트 단위로 나타냅니다. 이는 IPv4의 Total Length 필드와 유사하지만, IPv4의 Total Length는 전체 데이터그램의 길이를 나타내므로 헤더의 길이도 포함합니다.
- 다음 헤더(Next Header): 이 필드는 다음에 오는 헤더의 유형을 나타냅니다. IPv6 패킷의 페이로드를 구성하는 상위 레벨의 프로토콜을 나타냅니다. 예를 들어, TCP의 경우 Next Header 값은 6이며, UDP의 경우 17이다.
- 홉 제한(Hop Limit): 이 필드는 데이터그램이 네트워크를 통해 전달될 수 있는 최대 홉 수를 나타냅니다. 이는 IPv4의 Time to Live(TTL) 필드와 유사하지만, TTL은 시간 개념을 사용하는 반면, Hop Limit은 명확하게 홉 수를 사용합니다.

IPv4와의 주요 차이점 :

1. 각 홉에서의 처리 시간을 줄이기 위해 체크섬이 존재하지 않는다.
2. 옵션은 허용되나 헤더 외부에 위치하며, Next header 필드에 의해 표시된다.
3. IPv4는 패킷 분할이 MTU에 따라 모든 라우터에서 가능하지만 조립은 최종 목적지 호스트에서 이루어진다. 반면 IPv6에서는 패킷 분할과 조립 모두 종단 호스트(출발지, 목적지 노드)에서만 가능하다.


## Tunneling : IPv4 to IPv6 로 옮기기

현실적으로 모든 라우터의 프로토콜을 한번에 IPv6로 업그레이드 할 수 있는 일명 'Flag Day' 는 존재하지 않는다.

그래서 터널링을 통해 IPv4 라우터와 IPv6 라우터가 네트워크 상에서 공존할 수 있도록 한다.

터널링이란 IPv6 데이터그램을 IPv4 데이터그램의 페이로드로 넣어 전송하는 방법이다.
![](https://i.imgur.com/6pvOmpl.png)


![](https://i.imgur.com/e0NzIrn.png)
위 그림에서 라우터 B는 A로부터 전달받은 IPv6 데이터그램을 캡슐화하여 IPv4 패킷으로 만들고 해당 패킷의 페이로드에 기존의 IPv6 패킷이 들어가게 된다. 캡슐화된 패킷은 D를 거쳐 E 라우터로 전달하면, E라우터는 해당 패킷이 캡슐화된 IPv6 패킷임을 인식하고 디캡슐화 하여 F로 전송한다.

# ICMP - Internet Control Message Protocol

ICMP는 네트워크 계층에서 호스트 및 라우터들 사이에 네트워크 관련 정보를 전달하는데 사용된다.

ICMP 메세지는 IP데이터그램으로 전송되는데 만약 특정 IP 데이터그램이 ICMP 메세지를 포함한다면 IP 데이터그램의 헤더의 Protocol field의 값이 1이 들어가며 ICMP 메세지가 있다는 것을 인식하게 된다.

ICMP 메세지는 다음과 같은 필드들을 가진다.

Type : ICMP 메세지의 종류
Code : 메세지의 세부 종류
Checksum : 오류검사를 위한 값
Data : 메세지의 본문으로 Type 필드 값에 따라 다양한 정보가 들어간다.
![](https://i.imgur.com/5PSNSTj.png)

![](https://i.imgur.com/zskxTJu.png)

## TraceRoute

Traceroute는 경로를 추적하기 위해 Source 에서 특정 Destination으로 일련의 UDP 세그먼트들을 보내는 것이다. 이때 TTL 값이 0이 되는 순간 패킷이 버려지는 특성을 이용하게 된다.

첫 번째 데이터그램 세트의 TTL : 1
두 번째 // : 2
세 번째 // : 3

이런 식으로 전송하는 데이터그램의 TTL 값을 점점 늘려간다.
만약 N번째 데이터그램 세트가 N번째 라우터에 도착했다면 해당 라우터는 데이터그램 세트를 버림과 동시에 Source로 ICMP 메세지를 전송하게 된다(Type 11). 그리고 해당 메세지에는 라우터의 주소와 이름이 담고 있으며 Source는 해당 정보를 기록한다.

즉 Source측은 자신이 보낸 패킷이 목적지 까지 도달하는 경로를 구성하는 라우터들에 대한 정보를 파악할 수 있게 된다.

결국 데이터그램 세트는 Destination 호스트에 도달하게 되고 해당 호스트는 ICMP 메세지를 전송한다(Type3, Code 3). 해당 메세지를 수신한 Source는 데이터그램 전송을 멈추게 된다.

![](https://i.imgur.com/HwYVqra.png)




