---
title : React Next.js에서 SVGR을 이용해 효율적인 image asset 관리하기
date: 2023/05/08
author: 이인
tags: [next.js, React, svg, svgr, png, webpack]
---

# 개요

웹에서 고품질의 이미지 에셋을 제공하기 위한 방법은 여러가지가 존재한다. 아마도 주로 .png 혹은 .svg 포맷의 에셋을 사용할 것이다.

그리고 이런 이미지 에셋을 사용해야 하는 상황은 필자는 크게 두 가지로 생각했다. 

1. 게시글 내의 이미지와 같이 서버측에서 해당 에셋을 관리 및 전달해주거나, 클라이언트 측은 에셋의 주소만을 통해 이미지를 렌더링 하는 경우
2. 클라이언트 측의 도메인에서 요구하는 이미지 에셋 : UI 를 구성하는 아이콘 등의 이미지 에셋이 이에 해당한다.

이번 게시글에서 주요하게 다뤄볼 주제는 2번의 클라이언트측 이미지 에셋 관리에 대한 내용이다.

# SVG 와 PNG 의 차이 알아보기

모든 프로젝트에서 특정 기술이나 자원을 사용할 때, 대상이 필요한 이유가 무엇인지를 먼저 인지하고, 이를 통해 어떤 문제를 해결할 수 있는지를 인식하는 것이 먼저이다. 따라서 SVG 와 PNG 가 정확히 어떤 차이를 가지고 클라이언트 개발 시 SVG를 사용해야 하는 이유를 정당화 해보자.

## PNG

PNG(Portable Network Graphics)는 래스터 기반의 파일으로 고해상도, 무손실 압축, 투명도, 다양한 색상의 지원 등을 특징으로 가진다. 

래스터 파일 유형을 기반으로 하는 PNG는 이미지를 너무 확대하거나 축소할 경우 픽셀화 현상, 희미해짐 등의 현상이 나타날 수 있다. 높은 해상도를 지원하는 것과 별개로, 확대 및 축소에 따라 이미지 품질에 대한 한계가 있다.

또 PNG의 경우 고해상도 지원으로 인해 기본적으로 파일 크기가 무겁다. 따라서 이미지를 처리, 공유, 저장, 실행하는 데 시간이 더 걸려 페이지 로딩 시간이 길어진다.

다만 이미지의 품질을 최우선시 하는 상황에서, 세부 정보가 많은 고품질 디지털 사진의 인쇄, 편집 등에 사용할 수 있다.

## SVG

SVG는 수학 알고리즘을 기반으로 이미지를 표시하는 벡터 기반의 포맷이다.

SVG는 XML 언어를 기반으로 벡터를 작성하기 때문에, 확대 및 축소에 따른 이미지 품질 저하가 일어나지 않는다.

SVG 파일 YML 텍스트로 작성되기에, 픽셀 기반의 PNG 파일보다는 개별 파일 사이즈가 훨씬 더 작으므로 컴퓨터나 웹 사이트의 속도 저하에 크게 영향을 주지 않는다. 세부 정보가 많은 디자인이라면 느려질 수 있지만 PNG에 비하면 미미한 수준이다.

또 이런 텍스트는 스크린 리더와 검색 엔진이 파악할 수 있기에, 접근성과 SEO(검색 엔진 최적화) 측면에서 이점을 가진다.

## 무엇이 더 나은 선택인가?

일반적으로는 사이즈가 훨씬 작고, SEO와 지연시간에서 이점을 가지는 SVG가 더 좋은 선택이 될 것이다.  더군다나 XML을 기반으로 하기에, HTML 파싱과 같은 전문적인 작업에서 더욱 이점을 가질 수 있다.

다만 PNG와 SVG 모두 투명도를 조절할 수 있긴 해도, 특히 투명도와 픽셀이 중요한 경우라면 PNG가 더 나은 선택이 될 수 있다.

# 프론트엔드에서 SVG 파일을 주입하고 사용하는 방법

이제 각 이미지 포맷의 차이를 알아보았다. 결국 일반적인 상황에서는 웹에서 이미지 에셋을 사용하기 위해, SVG 확장자가 더 좋은 선택임을 알게 되었다.

## SVG 파일을 import 해서 컴포넌트로 변환하기 - 기본

일반적으로 리액트 혹은 리액트를 기반으로 하는 웹 프레임워크에서 SVG 를 사용하려면, 단순히 import를 통해 컴포넌트로 만들 수 있다.

이게 가능한 이유는 webpack 덕분이다.

기본적으로, React 프로젝트의 구성에서 Webpack이 사용되면 file-loader 또는 url-loader 등의 로더를 사용하여 이미지, 폰트, SVG 등의 파일들을 처리하도록 설정되는데, 이 때 JavaScript 모듈로 변환하여 처리한다.

/코드

결국 SVG 파일이 모듈화 되기 때문에 프로젝트 내에서 SVG 파일을 직접 import하고 활용할 수 있다.

import 된 SVG 모듈을 리액트 컴포넌트로 사용할 수 있는 이유는 @svgr/webpack 플러그인 덕분이다.

해당 플러그인이 SVG 모듈의 XML 코드를 자바스크립트 코드로 변환해준다. 변환된 코드는 React 의 Render 메서드에 추가되어 일반 컴포넌트처럼 활용할 수 있게 되는 것이다.

## 문제점 분석

### import 

좋다. webpack 덕에 우리는 아무런 어려움 없이 그저 svg 파일을 프로젝트 패키지에 주입하고, 사용하고 싶은 컴포넌트에서 단순히 import 하면 사용할 수 있다.

문제는 import 이다. 만약 하나의 페이지에서 보여주어야 하는 클라이언트 측 이미지 에셋이 10개 이상이라고 가정해보자. 10개의 SVG 모두 모듈화 해서 import 하고 렌더링한다.

이 때, 사용할 아이콘을 모두 import 해야 하기에 번거로울 뿐더러, 이미지 파일의 네이밍 규칙을 지정하지 않을경우, 일반적인 Import 시 해당 Import 모듈이 단순히 SVG 파일인지, 스타일링 컴포넌트인지, 일반 컴포넌트인지 파악하기 어렵다.


### 각 Asset 인식의 어려움

서비스의 UI 요구사항을 구현하기 위해 클라이언트 프로젝트 패키지에 필요한 이미지 에셋이 대략 100개라고 가정해 보자. 아무리 잘 설계된 디자인 시스템을 기반으로 개발을 진행한다고 해도, 각각의 이미지를 정확히 파악하려면 직접 해당 이미지를 열어보아야 한다.

### 커스텀 컴포넌트 제작의 어려움

에셋 관리의 어려움이나, import 문제를 해결하기 위해 패키지에 주입된 모든 아이콘을 관리하는 Higher Order Component를 만들려고 한다.

각 SVG는 매번 사이즈가 달라질 수 있고, 심지어 color 도 달라질 수 있다. 따라서 이를 커스터마이징 할 수 있도록 HOC에서 Viewport 사이즈와 ViewBox 사이즈 및 color를 props로 전달받고, 전달받은 props 를 다시 개별 SVG 컴포넌트에 전달할 수 있어야 한다.

그러나 webpack 을 통해 자동으로 모듈화 및 컴포넌트화 된 SVG에 임의의 props를 넘겨주려면 어려운 상황이 많을 뿐더러, 각 SVG 컴포넌트 마다 매번 개별 스타일링을 적용해야 한다.

### Lazy Loading

최적화를 위해 각 이미지 에셋을 Lazy Loading 방식으로 사용해야 하는 경우가 생긴다.

이 때, SVG 파일을 사용하려는 컴포넌트 내부에서 Lazy loading 과 Suspense 를 매번 처리해주어야 한다.

/코드

해당 파일을 사용하는 컴포넌트의 관점에서는, 단지 해당 이미지 컴포넌트를 사용하기 위해, 별도의 Boilerplate 코드를 매번 작성해 주어야 하는 셈이고, 필자는 이런 방식이 책임의 분리가 옳바르게 이루어지지 않았다고 본다.

### Type check 미지원

가장 불편했던 부분이다. 어떻게든 각 SVG 모듈을 통합하여 관리하는 컴포넌트를 만들고, 각 SVG를 구분하기 위해 name 이라는 props를 전달받아 name 에 맞는 SVG를 렌더링하는 컴포넌트가 있다고 가정해보자.

문제는 Typescript를 사용하는 환경에서, 런타임 이전에 name 의 리터럴 타입이 잘못되었는지 인식하지 못한다는 것이다.

대규모 프로젝트에서 여러개의 이미지 이름을 리터럴 타입을 매번 수정하기도 힘들 뿐더러, 지정하더라도 IDE 의 타입 추천 시스템을 활용할 수 없다.

/코드

위 코드 처럼 잘못된 string literal 전달에 대해서 런타임 이전에 확인할 수 없는 문제가 있었다.


# 커스텀 SVG 컴포넌트 만들기

## 문제를 바탕으로 요구사항 정의해보기

해당 문제에 있어 가장 중요했던건, 프로젝트의 모든 SVG 에셋을 통합하여 관리하는 추상화된 컴포넌트가 필요했다. 해당 컴포넌트는 다음과 같은 요구사항을 가진다.

1. viewport의 width, height 및 viewbox 사이즈와 fill 외에도 리액트에서 일반적으로 SVG에 대해 제공하는 모든 props를 전달받을 수 있어야 한다.
2. LazyLoading을 위한 Import 및 Suspense 코드 작성이 해당 컴포넌트를 사용하려는 외부 컴포넌트가 아닌 해당 컴포넌트의 내부에서 관리되어야 한다.
3. 통합 관리하는 모든 SVG에 대해 typing 가능해야 한다.
4. 변경에 유연하게 대응할 수 있어야 한다

## 1차 구현

해당 컴포넌트의 이름을 SVGIcon 이라고 명명하고, 구현을 위한 구조를 고민했다.
과정에서 SVG 의 Path 값만을 따로 객체로 관리하는 방식의 코드를 발견했고, 이를 참고하여 구현해 보기로 했다.

### DATA SET

SVG들의 path 값만 추출해 객체로 관리하기 위해 따로 모듈을 하나 만들어 준다.

/코드

이런식으로 ICON_SET 객체는 각 SVG의 path 와 기본 viewBox 사이즈를 속성으로 가지고, 추가적으로 필요한 속성이 있을 경우 등록할 수 있도록 타입을 정의했다.(문제가 많은 타입입니다..)

### 데이터 참조를 위한 훅 구현하기

props 로 전달된 icon name에 맞는 객체의 속성을 불러오는 함수를 구현한다. 외에도 viewbox, viewport 사이즈를 적용하기 위한 여러 함수를 작성한다. 마찬가지로 문제가 많은 함수이다.. 

/코드

### SVGIcon.tsx
앞서 구현했던 함수를 통해 ICON_SET 객체를 통해 통합된 SVG 에셋을 추출하여 사용하는 컴포넌트를 구현합니다.

/코드

## 1차 구현의 문제

1. 단일 path 파싱 불가능한 SVG
	figma 를 통해 아이콘을 추출하면서, 단일 path 만으로 파싱할 수 없는 SVG 도 있다는 것을 알았다. 현재까지의 구현으로는 여러가지 Rectangle, Circle 등을 다루는 SVG에 대한 대응을 할 수 없다.

 2. No Suspense & No lazy Loading
	lazy loading과 suspense 에 대해 컴포넌트 내부에서 자체적으로 처리하지 못했다.

가장 큰 문제는 단일 path 문제였다. 모든 SVG에 대응할 수 없다면, 가장 기본이 되는 이미지 렌더링 자체가 불가능했기 때문이다. 때문에 이러한 문제점과 다른 자잘한 코드상의 문제들을 보완하여 다시 리펙터링 한다.


# SVGR 을 사용하여 SVGIcon.tsx 리펙터링

 매번 다른 SVG의 xml 코드를 수동으로 파싱하고 객체에 등록하는 것은 매우 번거로운 과정이다. 따라서, 이를 스크립트로 자동화 하여, 객체의 속성으로 등록하는 것이 아닌, 개별 컴포넌트 구현체로 파싱하도록 진행한다.

이 때 각 SVG 파싱 결과 컴포넌트를 요구사항에 맞게 수정하기 위해 svgr.config.js 의 템플릿을 수정하여 진행한다.

과정에서 리액트 프로젝트에 내장된 SVGR 플러그인으로는, SVG를 통해 복잡한 작업을 수행할 때 많은 어려움이 있었기에, node_module 레벨이 아닌 프로젝트 레벨에서 svgr 플러그인을 설치해, 파싱 과정을 커스터마이징 하여 해당 문제를 해결하려 시도했다.

## svgr.config.js 작성

```
yarn add @svgr/webpack
```

해당 명령어를 통해 프로젝트 레벨에서 svgr 플러그인을 설치한다. 이후, svgr의 configuration을 조정하여 svg -> tsx 로 파싱하는 과정에서 원하는 형태의 tsx로 추출할 수 있도록 템플릿을 변경한다.

/코드

자체적으로 제공하는 componentName 과 tpl을 통해 파싱된 svg 컴포넌트의 props를 미리 지정해 두었다.

## next.config.js 수정

next.js 를 사용하고 있기 때문에, 내장된 파일로더가 svg 를 모듈로 만들지 않고, 프로젝트 레벨의 svgr 플러그인이 모듈화 하도록 next.config.js 의 config 객체에 다음과 같은 규칙을 추가한다. 다만 특수한 경우에는 기존의 파일로더가 처리하도록 설정한다.

/코드

## script 등록하기

복잡한 parsing 명령어를 간소화 하고 배포과정에서 빌드 스크립트로 실행 할 수 있게 package.json 에 스크립트를 등록한다. 이를 위해 먼저 svgr/cli를 설치한다.

```
yarn add @svgr/cli
```

이후 script 에 다음과 같은 명령어를 등록해준다.

/코드

문법은 'npx svgr [source directory] -d [destination directory]' 와 같다.

이제 터미널에서 yarn run build:svg 명령어를 입력하면 다음과 같이 파싱된 결과물을 볼 수 있다.

![](https://i.imgur.com/UAE2wMC.png)
그리고 개별 컴포넌트를 뜯어보면 svgr.config에서 설정했던 template 과 동일하게 파싱되었음을 알 수 있다.

/ 코드

## registry 객체에 컴포넌트 등록하기

이제 파싱된 모든 컴포넌트를 하나의 에셋으로 관리하기 위해 registry 객체를 생성해서, dynamic import 방식으로 등록해보자.

/코드

이렇게 함으로써 객체의 모든 키값을 타입으로 추출할 수 있고, 추출된 키 타입들은 이후 SVGIcon 의 name props의 타입으로 사용할 수 있다. 이렇게 하면 IDLE 에서 타입 추천을 못하던 문제를 해결하고, 런타임 이전에 잘못된 props 전달로 발생하는 오류를 잡아 체계적이고 안전하게 관리할 수 있다.

## registry, templates 를 기반으로 SVGIcon.tsx 리펙터링

/코드

React.lazy와 suspense를 통해 컴포넌트 내부에서 lazy loading 에 대해 자체적으로 처리하고 모든 SVG에 대해 개별이 아닌 통합으로 처리하게 되었다.

또 추후에는 RenderLoader 의 사이즈를 SVGIcon.tsx 가 전달받는 width, height 와 통일 시키거나 Spinner 등을 적용하여, suspense 상태에서 UI/UX 적인 어색함을 개선할 수 있을 것 같다.

다만 아직 개선이 필요한건, deploy 과정에서 파싱 스크립트 명령어를 등록하면 실제 프로덕션에서 수동적으로 SVG에 대한 추가적인 작업을 진행하지 않아도 상관없지만, 개발 단계에서 요구사항 변경 등으로 인한 새로운 SVG 주입, 삭제, 수정시 매번 스크립트 명령어를 실행하는 과정이 번거롭긴 하다. 이 부분에 대한 해결방안을 찾는다면 코드를 조금 더 정제시켜 오픈소스 라이브러리로 개발해 볼 계획이다.