---
title : Network Layer - Basic
date: 2023/06/08
author: '이인'
tags: ['Network Layer', 'CIDR', 'SUBNET', 'IP Class', 'Virtual Circuit','Datagram Network']
---

# 네트워크 레이어의 기능
1. 네트워크 레이어 프로콜은 모든 호스트와 라우터에 존재한다.
2. 네트워크 레이어의 주요한 기능은 fowarding 과 routing 이다.

- Fowarding :  수신한 패킷을 라우터의 입력 포트에서 출력포트로 전송하는 프로세스를 의미한다.
	- 네트워크 장비(스위치,라우터) 등에서 수행되는 작업이다.
	- 패킷의 목적지 주소를 기반으로 포워딩 테이블 혹은 스위칭 테이블을 사용해 해당 주소와 일치하는 출력포트를 결정한다
	- 포워딩은 단일 패킷의 처리에 집중한다.
- Routing : 네트워크에서 패킷의 목적지 주소를 기반으로 해당 패킷의 전달 **경로**를 결정하는 프로세스이다.
	- 라우팅 테이블을 통해 목적지 주소에 대한 next hop 을 결정한다


## Connection Setup
ATM에서 사용되는 기능으로, 네트워크에서 가상 회선 VC를 만들기 위한 과정이다.

데이터그램의 플로우 이전, 두 호스트와 호스트들을 잇는 라우터들을 포함한 VC을 만든다.

Connection Service의 경우 Transport Layer에서는 두 process 간의 Connection service를 제공하지만, Network Layer는 두 host 간 Connection Service 를 제공한다.

# 네트워크 레이어의 서비스

1. 개별 데이터 그램에 대한 서비스 :
	1. 전송을 보장한다.
	2. 40 mesc 보다 더 적은 딜레이를 보장한다
2. 데이터그램 흐름에 대한 서비스 :
	1. in-order : 패킷이 전송되는 순서대로 수신측에 도착하도록 보장한다.
	2. minimum-bandwidth to flow : 네트워크 상황에 종속되지 않고 항상 사용할 수 있는 최소한의 데이터 전송속도를 보장한다.
	3. 패킷 간 간격의 변화를 제한하여 패킷 전송 시간의 일관성을 유지한다.

## 네트워크 계층과 전송 계층의 차이점

서비스의 범위: 네트워크 계층은 호스트 간의 서비스를 제공하는 반면, 전송 계층은 프로세스 간의 서비스를 제공합니다.

서비스의 선택: 네트워크 계층은 일반적으로 하나의 서비스만을 제공합니다. 그러나 전송 계층에서는 사용자가 TCP (연결형) 또는 UDP (커넥션리스)와 같은 여러 서비스 중에서 선택할 수 있습니다.

구현 위치: 네트워크 계층의 서비스는 네트워크의 핵심 부분과 끝단 시스템에서 모두 구현될 수 있습니다. 그러나 전송 계층의 서비스는 주로 끝단 시스템에서만 구현됩니다.

## 네트워크 레이어 서비스 모델
![](https://i.imgur.com/Y4nN6Do.png)
ATM의 각 서비스 모델이 보장하는 서비스가 다르다.
- CBR (Constant Bit Rate): 일정한 전송 속도를 보장한다. 순서와 타이밍을 보장하고 패킷 손실이 발생하지 않는다.
    
- VBR (Variable Bit Rate): 사용자가 사전에 정의한 최소 및 최대 비트 전송률 사이에서 가변 비트 전송률을 조정한다. CBR와 마찬가지로 패킷의 순서와 타이밍을 보장하며 패킷 손실이 일어나지 않는다.
    
- ABR (Available Bit Rate): 트래픽 상황과 네트워크 혼잡 상태에 따라 비트 전송률을 동적으로 조정한다. 따라서 congestion feedback 을 보장한다. 패킷은 순서대로 도착하며 패킷의 손실과 타이밍을 보장하지는 않는다.
    
- UBR (Unspecified Bit Rate): 특정 비트 전송 속도를 보장하지 않습니다. UBR은 인터넷의 "best effort" 서비스와 비슷하게 동작합니다. 오직 패킷의 전송 순서만 보장한다.


# Virtual Circuit and Datagram Network

Datagram Network : Connectionless Service
	=> 각 패킷이 독립적으로 처리되며 명시적인 연결이 없다는 것을 의미, 각 패킷은 source to destination 이 각자의 경로를 따라 개별적으로 전송되며 도착할 때 순서대로 정렬되지 않을 수 있다.
Virtual Circuit Network : Connection Service
	=> 패킷들 사이의 논리적인 연결이 설정되며, 해당 연결을 통해 모든 패킷이 같은 경로로 전송된다. 즉 순서를 보장한다.


## Virtual Circuit

1. Call setup : 데이터 플로우 이전 각 호출에 대한 call setup 을 통해 출발지와 목적지 사이 경로가 설정된다. 이 설정은 네트워크의 모든 중간 라우터를 통과하며, 각 라우터는 이 정보를 자신의 포워딩 테이블에 기록한다.
3. VC Indentifier : 각 패킷은 목적지 호스트 주소가 아니라 VC Identifier 정보를 포함하고 있어, 해당 식별자를 통해 라우터는 패킷을 올바른 경로로 전송한다.
4. maintain state : source to destination path 상의 모든 라우터는 각각의 지나치는 connection에 대한 상태를 유지한다.
5. VC에는 대역폭, 버퍼와 같은 링크와 라우터 리소스가 할당될 수 있고, 이는 서비스의 예측 가능성을 높여준다.

### Virtual Circuit Implementation
VC는 Path, VC numbers, entries in forwarding tables 로 구성된다.

Path : 소스에서 목적지까지의 특정 경로를 정의한다. 해당 경로를 통해 패킷의 전송되는 경로, 방향을 결정한다

VC numbers : Path를 구성하는 각 링크에는 고유한 VC number가 할당되고, 해당 번호를 통해 특정 패킷이 어떤 VC에 속하는지 식별할 수 있다.

**VC Path를 구성하는 각 노드를 잇는 Link는 고유한 VC number를 가지는데 왜 각 패킷은 VC Identifier를 가지는가?**
=> Path 를 구성하는 각 라우터가 링크의 VC number 만으로 포워딩을 결정하는 것은 가능하지만, 각 링크는 지나치는 connection의 수에 따라 여러 개의 VC number를 가질 수 있고, 이 경우 라우터는, Link 및 각 VC에 대한 목적지 정보를 전부 관리해야 하기 때문에 구성이 복잡해지고 관리가 어려워 진다. 

반면 개별 패킷이 VC Identifier를 가진다면, call setup 과정에서 생성된 포워딩 정보를 바탕으로 라우터는 패킷을 보기만 하면 즉시 어디로 포워딩해야 하는지 알 수 있기 때문에 훨씬 단순하고 효율을 높일 수 있다.


Entries in fowarding tables in Router : VC path에 속한 각 라우터는 포워딩 테이블에 해당 가상회로에 대한 항목을 유지한다. 해당 항목(엔트리)는 들어오는 패킷의 VC number와 해당 VC number 패킷을 어디로 전달해야 하는지에 대한 정보를 유지한다. 

VC에서 상태를 유지한다는 것은 VC path를 구성하는 라우터가 포워딩 테이블의 항목을 유지하는 것을 의미한다.

![](https://i.imgur.com/WSKFSUT.png)

## Datagram Network

데이터그램 네트워크는 네트워크 레이어에서의 call setup을 수행하지 않는다. 즉 데이터그램 플로우 이전에 사전 경로 설정이 수행되지 않는다.

call setup 과정이 없기에 connectionless 한 방식으로 수행되고 라우터들은 개별 커넥션에 대한 상태를 유지하지 않게 된다.

개별 패킷은 식별자 대신 목적지 주소에 대한 정보를 가지고 있으며, 라우터들 또한 각 패킷의 목적지 주소 정보를 통해 포워딩을 수행하게 된다.

이때 목적지 주소는 단일 주소 혹은 주소 범위로 구성된다.

![](https://i.imgur.com/PjMn5cu.png)


### Longest Prefix Matching

포워딩 테이블에서 주소 범위를 기준으로 포워딩을 진행한다고 가정할 때, 명확하게 나누어지지 않는 항목이 존재할 수 있다.

예를 들어 다음과 같은 테이블이 있다고 가정해보자.
![](https://i.imgur.com/Whltm0L.png)

이때 11001000 00010111 0001xxxx xxxxxxxx 의 주소에 대해 0번, 1번, 2번 인터페이스 모두 매칭되는 주소값이라고 볼 수 있다.

이런 상황을 해결하기 위해 Longest Prefix Matching 방식을 사용한다.

![](https://i.imgur.com/1sLvpdT.png)

## Datagram Network vs VC

Datagram(Internet):
	- Elastic Service : 엄격한 타이밍 요구사항이 없는 탄력적 서비스를 제공
	- 탄력적이기 때문에 다양한 링크 타입이 존재한다
	- 패킷의 전송 속도, 손실, 순서 및 타이밍을 보장하지 않기 때문에 전체 네트워크는 심플하게 구성되지만 엣지(엔드 호스트)에서 원하는 서비스를 제공해야 하기 때문에 엣지의 복잡성은 올리는 방식
VC(ATM) : Datagram과 달리 패킷의 손실, 속도, 순서, 타이밍 등을 보장해야 하기 때문에 전체 네트워크는 복잡하게 구성되는 반면 엔드 시스템은 멍청하다.


# Router 뜯어보기

## Router Architecture Overview

Control Plane : 라우팅 테이블을 구축하고 유지하기 위해 라우팅 프로토콜을 실행하고 네트워크의 전체 상태를 이해하는 역할을 한다. 

Fowarding Data Plane : 컨트롤 플레인에서 생성된 라우팅 정보를 기반으로 실제 데이터 패킷을 포워딩하는 역할을 담당한다.

![](https://i.imgur.com/efWWUGF.png)

## Input Port Functions

![](https://i.imgur.com/dOb9R0b.png)

1. Line Termination  : Physical Layer로 물리적인 연결을 관리한다. 신호를 디지털 데이터로 변환하거나 반대로 디지털 데이터를 전송가능한 물리적 신호로 변환한다.
2. Link Layer Protocol : Link Layer로 패킷이 올바르게 전송되었는지를 확인한다. Ethernet과 같은 데이터 링크 계층 프로토콜이 해당된다. 또 MAC과 같은 물리적 주소를 처리한다.
3. Lookup and Forwarding Queueing : Lookup은 컨트롤 플레인의 라우팅 테이블에서 패킷의 목적지를 찾아 적절한 출력 포트로 포워딩하는 역할을 한다. 이 때 해당 패킷이 출력 포트로 전달되기 전에 큐에 임시 저장되는데 이를 Forwarding Queueing이라고 한다. 해당 큐를 통해 패킷이 출력포트로 전달되는 순서를 제어하며 QOS의 중요한 역할을 한다.

입력 포트 큐잉 : 스위칭 패브릭의 패킷 포워딩 속도 보다 모든 입력포트의 전송 속도의 합 보다 느릴 경우 입력 포트의 큐에 패킷이 쌓이게 되고, 입력 버퍼가 가득찼을 때 패킷 손실과 큐잉 지연등의 문제가 발생할 수 있다.

Head of the Line(HOL) Blocking : 큐의 헤드에 위치한 패킷이 다른 패킷의 전송을 방해하는 현상이다.

두 개 이상의 패킷이 동시에 같은 출력 포트로 전송되려고 할 때, 출력 포트 경쟁이 발생하게 되고 이 경우 한 번에 하나의 패킷만 전송할 수 있으므로 나머지 패킷은 큐에서 대기하는 상태가 되며 이때 대기하는 패킷을 가지는 입력포트에서 HOL 문제가 발생할 수 있다.

## Switching Fabrics
스위칭 패브릭은 입력포트에서 수신된 패킷을 적절한 출력포트로 전달하는 역할을 한다.

스위칭 방식에 따라 Memory, Bus, Crossbar Interconnection 방식으로 나눌 수 있다.
### Memory Switching
![](https://i.imgur.com/qw0WegD.png)
1. 입력 포트가 패킷을 수신하고 시스템 버스를 통해 메모리에 저장한다.
2. CPU가 패킷을 처리하여 적절한 출력포트를 결정한다.
3. 시스템 버스를 통해 메모리에 복사된 패킷을 출력 포트로 이동한다.

따라서 스위칭 속도는 메모리 대역폭에 의해 제한된다.
### Bus Switching
![](https://i.imgur.com/X8OWdyN.png)
입력 포트로 수신된 패킷이 스위칭 패브릭의 공유 버스를 통해 적절한 출력 포트로 전달된다.

이 방식은 공유 버스의 대역폭이 스위칭 속도를 제한한다.
### Crossbar Interconnection Switching
![](https://i.imgur.com/noUNqxl.png)
버스를 통한 스위칭 방식의 속도가 공유 버스의 대역폭에 따른 제한이 있다는 문제점을 극복하기 위한 스위칭 방식이다.

여러 입력 포트와 출력포트 사이에 그리드 형태의 버스 연결을 생성하여 각 입력,출력 포트 쌍이 독립적인 버스 경로를 가지게 하여 병목현상이 발생하지 않도록 한다.

그러나 구현이 복잡하고 동기화 문제가 발생할 수 있다.
더욱 발전된 형태로 Banyan Network 방식이 있다.


## Output port

Input Port의 구성요소가 역배치 되어있는 구조이다.
![](https://i.imgur.com/41KdlqL.png)

1. Buffering : 패킷이 네트워크 장치를 통과하는 동안 각 포트에서 버퍼링이 발생하게 된다. 스위칭 패브릭에서 패킷ㅎ이 도착하는 속도가 output port의 패킷 전송 속도보다 더 높을 경우 버퍼링이 발생하는데, 만약 버퍼가 가득 찬 상태에서 새로운 패킷이 도착한다면 해당 패킷이 손실될 수 있다.
2. Scheduling Discipline : 스케쥴링 규칙은 패킷이 전송되는 순서를 결정한다. 기본적으로 Queue 구조에 맞게 FIFO 방식을 가진다. 그러나 현실적으로 모든 패킷이 동일한 Priority를 가지지 않으므로 Priority 에 따라 전송 순서를 결정하는 Priority Scheduling 방식도 존재한다. 그러나 이런 우선순위 스케쥴링은 네트워크 공정성에 어긋난다는 논의가 있다.



# IP : Internet Protocol


## IP Datagram Format
![](https://i.imgur.com/qDoZzlE.png)

1. **Version (버전):** IP 프로토콜의 버전 번호입니다. 현재 대부분은 IPv4(버전 4)이나, 점차 IPv6(버전 6)가 보편화되고 있습니다.
    
2. **Header Length (헤더 길이):** IP 헤더의 길이를 4바이트 단위로 나타냅니다. 만약 Header Length 의 비트가 5라는 수를 나타낸다면, IP 헤더의 길이는 5 * 4 = 20 바이트를 의미한다.
    
3. **Type of Service (서비스 타입):** 데이터그램의 우선 순위 및 서비스 유형을 지정합니다.
    
4. **Total Length (전체 길이):** 데이터그램의 전체 길이를 바이트 단위로 나타냅니다. 헤더와 페이로드 부분을 모두 포함합니다. 16비트로 구성되어 최대 값은 2^16 -1 = 65535 바이트이다. 이 크기는 IP 패킷 단일의 최대 크기를 나타낸다.
    
5. **Identification (식별자):** 데이터그램을 식별하기 위한 16비트 식별자입니다. 이 필드는 데이터그램이 분할되었을 때 재조립하는 데 사용됩니다.
    
6. **Flags (플래그):** 특정 조건을 표시하는 데 사용되는 비트들입니다. 일반적으로 데이터그램의 분할을 제어하는 데 사용됩니다. 3비트
    
7. **Fragment Offset (분할 오프셋):** 원래 데이터그램에서 이 데이터그램 조각의 위치를 나타내는 데 사용됩니다. 13비트로 이루어진다. 8바이트 단위로 위치를 나타낸다. 예를 들어 Fragment Offset 필드의 비트들이 185라는 수를 이진수로 나타낸다면, 데이터그램 플로우에서 해당 패킷 조각이 원본 데이터 그램의 185 * 8 = 1480 번째 바이트에서 시작한다는 것을 의미한다.
    
8. **Time to Live (TTL):** 데이터그램이 네트워크에서 얼마나 오래 살아있을 수 있는지를 나타내는 값입니다. 일반적으로 이 값은 각 라우터를 통과할 때마다 감소합니다.
    
9. **Protocol (프로토콜):** 데이터그램의 페이로드(payload)를 어떤 상위 계층 프로토콜에 전달해야 하는지를 나타냅니다.
    
10. **Header Checksum (헤더 체크섬):** 헤더의 오류 검출을 위한 체크섬 값입니다.
    
11. **Source IP Address (출발지 IP 주소):** 데이터그램을 보낸 호스트의 IP 주소입니다.
    
12. **Destination IP Address (목적지 IP 주소):** 데이터그램을 받을 호스트의 IP 주소입니다.
    
13. **Options (옵션):** 선택적으로 추가할 수 있는 추가 정보입니다. 이는 타임스탬프, 경로 기록, 방문해야 하는 라우터 목록 등을 포함할 수 있습니다.
    
14. **Data (데이터):** 실제의 페이로드로, 일반적으로 TCP나 UDP 세그먼트를 포함합니다.


Overhead : 20bytes for IP + 20 bytes for TCP  = 40bytes + app layer overhead

## IP Fragmentation, reassemble

Network의 각 노드를 잇는 링크는 MTU 값을 가진다. MTU 는 Max Transfer Unit 으로 한번에 보낼 수 있는 데이터의 최대 크기를 의미한다. 즉 보내려고하는 패킷의 크기가 해당 링크의 MTU 보다 크다면, MTU 크기에 맞게 IP Datagram을 분할해야 한다.

분할된 데이터그램들은 오직 최종 목적지 노드에서 다시 결합된다.

분할된 데이터그램들을 인식하기 위해 IP 데이터그램의 헤더에 있는 length, Identification, FragFlags, Fragmentation Offset 필드를 사용한다.
![](https://i.imgur.com/uUk7Lgd.png)

해당 예시에서 MTU 는 1500 바이트이고, 송신하려는 데이터그램의 크기는 Length 필드에 따라 4000바이트이다. 

따라서 해당 데이터그램을 3개의 데이터그램으로 쪼개어 전송하게 되는데 이 때의 IP Header의 Length 필드가 가리키는 크기는 헤더 크기 + 페이로드 크기 이다.

즉 분할된 데이터그램 모두가 IP Header를 가지고 있어야 한다. 세 개의 데이터그램 중 첫 번 째 데이터그램은 분할 이전 데이터그램의 헤더를 그대로 사용하여 1500바이트 중 1480바이트가 페이로드 크기이다.

두 번째 데이터그램은 새로운 IP Header를 생성하여 부착했고 마찬가지로 1500 바이트 중 1480 바이트가 페이로드 크기이다.

마지막 데이터그램은 3980 - 2960 = 1020 만큼의 페이로드 데이터를 전송해야 하고, 추가적인 IP Header가 붙으므로 1040바이트가 전체 데이터그램 크기이고 페이로드 크기는 1020바이트 이다.

이때 Fragmentation Offeset 필드의 값을 계산하려면, 해당 데이터그램 이전까지의 모든 데이터그램의 페이로드 크기를 다 더해서 8로 나누면 된다.

Identification 필드는 분할된 각 데이터그램이 하나의 데이터그램 흐름이라는 것을 식별하기 위한 필드이다. 즉 ID 필드 값이 같은 데이터그램들은 모두 하나의 데이터그램에서 분할된 데이터그램들이다.

Flag 필드가 001 이면 해당 데이터그램 흐름에서 현재의 데이터그램은 마지막 데이터그램 패킷이 아니라는 의미이고, 000이면 데이터그램 흐름에서 마지막 데이터그램 패킷이라는 의미를 가진다.

![](https://i.imgur.com/8KHhe0G.png)

## IP Address

IP Datagram 헤더는 Source 및 Destination 의 IP Address 정보가 포함된다.

IP 주소는 Network Id + Host Id 로 구성된다.

Network ID : 해당 장치가 어떤 네트워크에 속하는지를 식별하는데 사용되며 동일한 네트워크에 있는 모든 장치에 대해 동일한 Network ID를 가진다.

Host ID : 전체 IP 주소에서 Network ID 부분을 제외한 나머지 부분으로 특정 네트워크 내에서 특정 호스트를 식별하는데 사용된다.


## IP Adress Class
![](https://i.imgur.com/QhembbY.png)

**Class A**

- 첫 번째 8비트 (octet)는 1~126의 값을 가질 수 있습니다.
- 0.0.0.0은 예약되어 있고, 127.0.0.0은 loopback 주소로 예약되어 있습니다.
- 이론상 전체 주소 범위는 0.0.0.0 ~ 127(네트워크)/.255.255.255(호스트) 이다.
- 대규모 네트워크에 사용되며, 약 16백만 개의 호스트 주소를 제공합니다.

**Class B**

- 첫 번째 8비트는 128~191의 값을 가질 수 있습니다.
- 전체 범위는 128.0.0.0에서 191.255(네트워크)/.255.255(호스트) 이다.
- 중규모 네트워크에 사용되며, 약 6만 5천 개의 호스트 주소를 제공합니다.

**Class C**

- 첫 번째 8비트는 192~223의 값을 가질 수 있습니다.
- 전체 범위는 192.0.0.0에서 223.255.255(네트워크)/.255(호스트)
- 소규모 네트워크에 사용되며, 약 256개의 호스트 주소를 제공합니다.

**Class D**

- 첫 번째 8비트는 224~239의 값을 가질 수 있습니다.
- 전체 범위는 224.0.0.0에서 239.255.255.255입니다.
- 이 클래스는 멀티캐스트 주소에 사용됩니다.

**Class E**

- 첫 번째 8비트는 240~255의 값을 가질 수 있습니다.
- 전체 범위는 240.0.0.0에서 255.255.255.254입니다.
- 이 클래스는 연구 및 실험용으로 예약되어 있습니다.


IP Class 방식은 IP 주소 공간의 소진을 빠르게 만드는 단점이 있어서, 현재는 CIDR: Classless InterDomain Routing 를 사용

## Subnet

하나의 큰 네트워크가 분할되어 나누어진 작은 네트워크를 서브넷이라 한다. 라우터나 호스트를 거치지 않고 서로간 통신이 가능한 범위의 네트워크를 서브넷이라 정의할 수 있다.

서브넷 내부에서는 물리적 라우터를 거치지 않고 통신할 수 있기에 트래픽 관리에 효과적이고, IP 주소 공간을 보다 효율적으로 사용할 수 있다.

IP 주소를 구성하는 NetworkID를 해당 서브넷의 주소라고 볼 수 있다.

![](https://i.imgur.com/htR8b53.png)



## CIDR

전체 아이피 주소 중, 서브넷 파트(Network Id + Subnet Id) 를 표현하기 위해 차지하는 비트 수를 /x 를 통해 표현하는 방법이다.

![](https://i.imgur.com/kSOSB8G.png)

예를 들어 위 이미지 처럼 200.23.16.0/23 일 경우 전체 32비트중 서브넷 파트가 차지하는 부분은 23비트, 즉 호스트 ID 를 할당 가능한 비트는 총 32-23 = 9 비트이다.
즉 2^9 만큼의 호스트 주소를 가리킬 수 있다.

만약 X 만큼의 호스트 주소를 지원해야 한다면

2^y > X 인 y값을 찾고, 해당 y는 Host ID 를 표현하는 비트의 수 라고 볼 수 있다. 이때 서브넷 파트의 비트 수는 32-y가 된다.

![](https://i.imgur.com/AXCXzKy.png)



